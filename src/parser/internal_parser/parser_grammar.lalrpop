use parser::internal_parser::ast::{Term, Formula};

grammar;

pub Formula: Formula = {
    EquivalentFormula
};

EquivalentFormula: Formula = {
    <l: EquivalentFormula> "<=>" <r: ImpliesFormula> => Formula::Equivalent(Box::new(l), Box::new(r)),
    ImpliesFormula
};

ImpliesFormula: Formula = {
    <l: ImpliesFormula> "==>" <r: OrFormula> => Formula::Implies(Box::new(l), Box::new(r)),
    OrFormula
};

OrFormula: Formula = {
    <l: OrFormula> "\/" <r: AndFormula> => Formula::Or(Box::new(l), Box::new(r)),
    AndFormula
};

AndFormula: Formula = {
    <l: AndFormula> r"/\\" <r: NotFormula> => Formula::And(Box::new(l), Box::new(r)),
    NotFormula
};

NotFormula: Formula = {
    "~" <f: NotFormula> => Formula::Not(Box::new(f)),
    "forall" <s: TermName> "." <f: NotFormula> => Formula::Forall(s, Box::new(f)),
    "exists" <s: TermName> "." <f: NotFormula> => Formula::Exists(s, Box::new(f)),
    PredicateFormula
};

PredicateFormula: Formula = {
    <l: Term> "=" <r: Term> => Formula::Predicate("=".to_owned(), vec!(l, r)),
    <l: Term> "<>" <r: Term> => Formula::Not(Box::new(Formula::Predicate("=".to_owned(), vec!(l, r)))),
    Predicate,
    "(" <Formula> ")"
};

Predicate: Formula = {
    <PredicateName> "(" <TermList> ")" => Formula::Predicate(<>),
    <s: PredicateName> => match &*s {
            "T" => Formula::True, 
            "F" => Formula::False,
            _ => Formula::Predicate(s, Vec::new())
        }
};

pub Term: Term = {
    Function,
    Variable
};

Function: Term = {
    <TermName> "(" <TermList> ")" => Term::Function(<>)
};

TermList = List<Term>;

Variable: Term = {
    TermName => Term::Variable(<>)
};

PredicateName: String = {
    <s: r"[A-Z][a-zA-Z0-9]*"> => s.to_string()
};

TermName: String = {
    <s: r"[a-z][a-zA-Z0-9]*"> => s.to_string()
};

List<T>: Vec<T> = {
    <v: (<T> ",")+> <t: T> => {
            let mut v = v;
            v.push(t);
            v
        },
    <opt_t: T?> => match opt_t {
            Some(t) => vec!(t),
            None => vec!()
        }
};